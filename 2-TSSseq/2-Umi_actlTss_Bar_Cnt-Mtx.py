### python 3 codes ###
# remotely use Pitt HTC cluster
# python=python/anaconda3.8-2020.11 (Python 3.8.5.final.0); pandas=1.1.3; numpy=1.19.2;

### To extract critical region from reads that have expected sequence composition:
    # [5'-end 15nt adapter barcode] - [Actual TSS region in RNA read] - [24bp barcode_v2] - [ATGTC] - [CKO2191] - [s128A]
# Standard: 1) ATGTC+CKO2191 is found;
          # 2) ATGTC+CKO2191 sequence starts at at least 41st position (expected [15nt]+[>=1nt]+[24nt] >= 40nt);

# Input-1: [DTmerge-MASTER-all_final-info_table.csv] containing information for all MASTER samples
# Input-2s: TSSseq_b1 fastq files for each sample
    # WT & E1103G & F1086S samples:
        # each sample has 1 fastq file
    # G1097D & H1085Q samples:
        # each sample has 4 fastq files generated by 4 lanes:
        # [Vv*_S*_L001_R1_001.fastq] [Vv*_S*_L002_R1_001.fastq] [Vv*_S*_L003_R1_001.fastq] [Vv*_S*_L004_R1_001.fastq]

# Output-1: [*-Umi_actlTss_Bar_Cnt-Mtx.txt]
    # 4 columns, sep = '\t': [5UMI]-[actlTSS]-[Barcode24]-[RNA_Count]
    # file prefix naming: library_mutant_replicate_b1
# Output-2: [-xPrf.fastq]: reads that don't have expected composition
    # file prefix naming: library_mutant_replicate_b1
# Output-3: [2-Umi_actlTss_Bar_Cnt-Mtx-info.csv], details for processed samples

import datetime
job_start = datetime.datetime.now()
print(job_start)

import pandas as pd

cmn_folder = '/bgfs/ckaplan/Yunye/0-common_files/'
inp_folder = '/bgfs/ckaplan/Yunye/3-TSS_sequence_library/12345-Ts_b1-extr_CX_ddp/1-fastq/'
out_folder = '/bgfs/ckaplan/Yunye/3-TSS_sequence_library/12345-Ts_b1-extr_CX_ddp/2-Umi_actlTss_Bar_Cnt-Mtx/'

smp_info = pd.read_csv(cmn_folder+'DTmerge-MASTER-all_final-info_table.csv', na_filter= False) # w/o filling empty cells as NaN
# to process TSSseq_b1 of all final samples (3x3x5=45):
smp_info = smp_info[smp_info['final'] == 'yes']

# table to collect info for each sample
op_info = smp_info[['super_id','PolII','lib','rep','Tseq-fastq_B1']].set_index('super_id')

for _, smp in smp_info.iterrows():
    file_prefix = smp['lib']+'_'+smp['PolII']+'_'+smp['rep']+'_b1-'
    op_info.loc[smp['super_id'],'file_prefix'] = file_prefix

    fout1 = open(out_folder+file_prefix+'Umi_actlTss_Bar_Cnt-Mtx.txt', 'w')
    print("%s\t%s\t%s\t%s" % ("5UMI", "actlTSS", "Barcode24", "RNA_Count"), file = fout1)
    fout2 = open(out_folder+file_prefix+'xPrf.fastq', 'w')
    
    ATGTC_CKO2191seq = 'ATGTC'+'TAAAGGTGAAGAATTATTCACT'
    line_num = 0
    counted_reads = 0 # to record how many reads have expected sequence composition
    Umi_TSS_Bar_counts = dict()
    
    # for WT & E1103G & F1086S: 1 fastq file for each sample
    if smp['PolII'] in ['WT','E1103G','F1086S']:
        for line in open(inp_folder+smp['Tseq-fastq_B1'], 'r') :
            line_num += 1 # which line is in processing    
            ln_read = line_num % 4  # which line of each read: 1-identifier; 2-sequence; 3-'+'; 4-quality values
            
            if ln_read == 1:
                identifier_line = line.rstrip()
            elif ln_read == 2:
                seq_line = line.rstrip()
            elif ln_read == 3:
                line3 = line.rstrip()
            elif ln_read == 0:
                quality_line = line.rstrip()
                
                position = seq_line.find(ATGTC_CKO2191seq) # to search ATGTC+CKO2191 seq in read
                # if matching to expected composition:
                    # expect [15nt]+[>=1nt]+[24nt] >= 40nt => ATGTC_CKO2191seq starts at at least pos 41 => index >=40
                if position >=40:
                    counted_reads +=1
                    umi = seq_line[0:15] # extract 15nt 5'-end UMI (adapter barcode)
                    actlTSS = seq_line[15:(position-24)] # extract actual TSS region in RNA read
                    barcode = seq_line[(position-24):position] # extract 24nt barcode_v2 region
                    Umi_TSS_Bar = umi + '_' + actlTSS + '_' + barcode # to get 5'Bar_TSS_Barcode combined seq for saving into dict
                    Umi_TSS_Bar_counts[Umi_TSS_Bar] = Umi_TSS_Bar_counts.get(Umi_TSS_Bar,0) + 1 # count for 5'Bar_TSS_Barcode variant
                else: # not perfectly matching to expectation
                    print("%s\n%s\n%s\n%s" % (identifier_line, seq_line, line3, quality_line), file = fout2)
    # for G1097D & H1085Q: 4 fastq files=4 lanes for each sample
    elif smp['PolII'] in ['G1097D','H1085Q']:
        for lane in ['L001','L002','L003','L004']:
            for line in open(inp_folder+smp['Tseq-fastq_B1'].replace('L001',lane), 'r'):
                line_num += 1 # which line is in processing
                ln_read = line_num % 4  # which line of each read: 1-identifier; 2-sequence; 3-'+'; 4-quality values
                
                if ln_read == 1:
                    identifier_line = line.rstrip()
                elif ln_read == 2:
                    seq_line = line.rstrip()
                elif ln_read == 3:
                    line3 = line.rstrip()
                elif ln_read == 0:
                    quality_line = line.rstrip()
                
                    position = seq_line.find(ATGTC_CKO2191seq) # to search ATGTC+CKO2191 seq in read
                    # if matching expected composition:
                        # expect [15nt]+[>=1nt]+[24nt] >= 40nt => ATGTC_CKO2191seq starts at at least pos 41 => index >=40
                    if position >=40:
                        counted_reads +=1
                        umi = seq_line[0:15] # extract 15nt 5'-end UMI (adapter barcode)
                        actlTSS = seq_line[15:(position-24)] # extract actual TSS region in RNA read
                        barcode = seq_line[(position-24):position] # extract 24nt barcode_v2 region
                        Umi_TSS_Bar = umi + '_' + actlTSS + '_' + barcode # to get 5'Bar_TSS_Barcode combined seq for saving into dict
                        Umi_TSS_Bar_counts[Umi_TSS_Bar] = Umi_TSS_Bar_counts.get(Umi_TSS_Bar,0) + 1 # count for 5'Bar_TSS_Barcode variant
                    else: # not perfectly matching to expectation
                        print("%s\n%s\n%s\n%s" % (identifier_line, seq_line, line3, quality_line), file = fout2)    
            
    var_num = 0 # to record how many different UMI_TSS_Barcode variants
    
    for var, count in Umi_TSS_Bar_counts.items():
        var_num += 1
        Umi_TSS_Bar_split = var.split('_')
        print("%s\t%s\t%s\t%d" % (Umi_TSS_Bar_split[0], Umi_TSS_Bar_split[1], Umi_TSS_Bar_split[2], int(count)), file = fout1)

    op_info.loc[smp['super_id'],'n_reads_processed'] = line_num/4
    op_info.loc[smp['super_id'],'n_reads_expected'] = counted_reads
    op_info.loc[smp['super_id'],'n_Umi_actlTSS_Bar_variants'] = var_num

op_info.reset_index().to_csv('2-Umi_actlTss_Bar_Cnt-Mtx-info.csv', sep=',', index=False, header=True, mode='w')

job_end = datetime.datetime.now()
print("job finished in", datetime.timedelta.total_seconds(job_end - job_start)/60, 'mins at', job_end)
